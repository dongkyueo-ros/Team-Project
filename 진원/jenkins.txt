import java.text.SimpleDateFormat
import java.util.TimeZone

// 파일 내용 변경 여부 확인 함수
def isFileContentChanged(filePath) {
    def previousCommit = sh(script: "git rev-parse HEAD^", returnStdout: true).trim()
    def currentCommit = sh(script: "git rev-parse HEAD", returnStdout: true).trim()
    def diff = sh(script: "git diff ${previousCommit} ${currentCommit} -- ${filePath}", returnStdout: true)
    return diff != ''
}

// 디렉토리 내용 변경 여부 확인 함수
def isDirectoryChanged(String dirPath) {
    def previousCommit = sh(script: "git rev-parse HEAD^", returnStdout: true).trim()
    def currentCommit = sh(script: "git rev-parse HEAD", returnStdout: true).trim()
    def diff = sh(script: "git diff ${previousCommit} ${currentCommit} -- ${dirPath}", returnStdout: true)
    return diff != ''
}

// 소스 또는 Dockerfile 변경 여부 확인 함수
def isSourceOrDockerFileChanged(String dirPath) {
    def previousCommit = sh(script: "git rev-parse HEAD^", returnStdout: true).trim()
    def currentCommit = sh(script: "git rev-parse HEAD", returnStdout: true).trim()
    def diff = sh(script: "git diff ${previousCommit} ${currentCommit} -- ${dirPath}", returnStdout: true)
    return diff.contains('Dockerfile') || diff.split("\n").any { it.matches('.*(\\.tar|\\.js|\\.py)$') }
}

// Docker 이미지의 기반 이미지 추출 함수
def extractBaseImage(String dockerFilePath) {
    def dockerFileContent = readFile(dockerFilePath)
    def fromLine = dockerFileContent.split("\n").find { it.startsWith('FROM') }
    return fromLine ? fromLine.split(' ')[1].split(':')[0] : null
}

// 다른 변경 사항 확인 함수
def isOtherChanges() {
    def previousCommit = sh(script: "git rev-parse HEAD^", returnStdout: true).trim()
    def currentCommit = sh(script: "git rev-parse HEAD", returnStdout: true).trim()
    def diff = sh(script: "git diff ${previousCommit} ${currentCommit}", returnStdout: true)
    return diff.split("\n").any { !(it.startsWith("Image/")) && !(it.startsWith("Terraform/")) }
}

// Jenkinsfile 또는 YAML 파일 변경 여부 확인 함수
def isJenkinsfileOrYamlChanged = {
    def diffOutput = sh script: "git diff HEAD^ HEAD -- Jenkinsfile '*.yml'", returnStdout: true
    return (diffOutput != null) && diffOutput.trim() != ''
}

def buildNumber = env.BUILD_NUMBER


pipeline {
    agent any
    environment {
        DOCKER_CREDENTIALS = credentials('aws_connection')
        AWS_CREDENTIALS = credentials('aws_connection')
        S3_BUCKET = 'jwdemo15351'
        BASTION_HOST = 'bastion.jwdemo.click'
    }

    stages {
        stage('Declarative: Checkout SCM') {
            steps {
                checkout scm
            }
        }

        stage('Check Changes') {
            steps {
                script {
                    def terraformChanged = isFileContentChanged('Terraform/**.tf')
                    def dockerOrSourceChanged = isDirectoryChanged('Image/*')
                    env.RUN_TERRAFORM = terraformChanged ? 'true' : 'false'
                    env.RUN_DOCKER = dockerOrSourceChanged ? 'true' : 'false'
                    echo "Terraform Changed: ${env.RUN_TERRAFORM}"
                    echo "Docker or Source Changed: ${env.RUN_DOCKER}"
                }
            }
        }

        stage('Terraform Apply') {
            when { expression { env.RUN_TERRAFORM == 'true' } }
            steps {
                script {
                    echo "Terraform code has changed. Applying..."
                    def terraformPath = sh(script: "find ${WORKSPACE}/Terraform -type f -name \"*.tf\" | head -n 1 || echo \"none\"", returnStdout: true).trim()
                    if (terraformPath != 'none') {
                        def terraformDir = terraformPath.replaceAll("/[^/]+\$", "")
                        dir(terraformDir) {
                            sh "terraform init"
                            sh "terraform plan -out=myplan"
                            sh "terraform apply myplan"
                        }
                    } else {
                        echo "No Terraform code found."
                    }
                }
            }
            post {
                success {
                    script {
                        def koreaTime = new Date().format("yyyy-MM-dd HH:mm:ss", TimeZone.getTimeZone('Asia/Seoul'))
                        def message = ":white_check_mark: 빌드번호 : ${buildNumber}\n테라폼 배포 성공!\n작업 시간: ${koreaTime}"
                        slackSend(channel: '#ott_noti', message: message)
                    }
                }
                failure {
                    script {
                        def koreaTime = new Date().format("yyyy-MM-dd HH:mm:ss", TimeZone.getTimeZone('Asia/Seoul'))
                        def message = ":x: 빌드번호 : ${buildNumber}\n테라폼 배포 실패!\n작업 시간: ${koreaTime}"
                        slackSend(channel: '#ott_noti', message: message)
                    }
                }
            }
        }

        stage('Build and Push Docker Image') {
            steps {
                script {
                    def services = ['httpd', 'php']

                    // Image 디렉토리 내에서 서비스를 동적으로 탐지
                    dir("Image") {
                        // 'ls -d */' 명령어로 서브디렉토리 목록을 가져오고, @tmp 디렉토리를 제외
                        services = sh(script: "find . -mindepth 1 -maxdepth 1 -type d -not -name '*@tmp*' -exec basename {} \\;", returnStdout: true).trim().split("\n")
                    }


                    if (env.RUN_DOCKER == 'true') {
                            echo "Building and pushing Docker image for ${service}..."
                            def baseImage = extractBaseImage(dockerFilePath)
                            def imageName = "${service}-${buildNumber}"
                    services.each { service ->
                        def dockerFilePath = "Image/${service}/Dockerfile"
                        def sourceTarPath = "Image/${service}/*.tar"
                        def dockerImageNeedsBuilding = isSourceOrDockerFileChanged(dockerFilePath) || isSourceOrDockerFileChanged(sourceTarPath)

                        

                            dir("Image/${service}") {
                                withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws_connection', accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
                                    sh "aws ecr get-login-password --region ap-northeast-2 | docker login --username AWS --password-stdin 790267619968.dkr.ecr.ap-northeast-2.amazonaws.com"
                                    sh "docker build -t my-image:${imageName} ."
                                    sh "docker tag my-image:${imageName} 790267619968.dkr.ecr.ap-northeast-2.amazonaws.com/dockerimage:${imageName}"
                                    sh "docker push 790267619968.dkr.ecr.ap-northeast-2.amazonaws.com/dockerimage:${imageName}"
                                }
                                sshagent(credentials: ['bastion_id']) {
                                    sh """
                                        ssh -o StrictHostKeyChecking=no ec2-user@${BASTION_HOST} '
                                        kubectl set image deployment/${service}-deployment ${service}-container=790267619968.dkr.ecr.ap-northeast-2.amazonaws.com/dockerimage:${imageName}
                                        '
                                    """
                                }
                            }
                        } 
                        }
                        else if (env.RUN_DOCKER == 'false' && !isJenkinsfileOrYamlChanged()) {
                            sshagent(credentials: ['bastion_id']) {
                                boolean deploymentExists = sh script: """
                                    ssh -o StrictHostKeyChecking=no ec2-user@${BASTION_HOST} 'kubectl get deploy'
                                """, returnStatus: true

                                if (deploymentExists != 0) {
                                    echo "Deployment does not exist. Building and pushing Docker image for all services, and creating new deployment..."
                                    services.each { innerService ->
                                        def innerDockerFilePath = "Image/${innerService}/Dockerfile"
                                        // 여기에서 innerService 이름과 빌드 번호를 결합하여 이미지 태그 생성
                                        def innerImageName = "${innerService}-${env.BUILD_NUMBER}"

                                        dir("Image/${innerService}") {
                                            withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws_connection', accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
                                                sh "aws ecr get-login-password --region ap-northeast-2 | docker login --username AWS --password-stdin 790267619968.dkr.ecr.ap-northeast-2.amazonaws.com"
                                                sh "docker build -t my-image:${innerImageName} ."
                                                sh "docker tag my-image:${innerImageName} 790267619968.dkr.ecr.ap-northeast-2.amazonaws.com/dockerimage:${innerImageName}"
                                                sh "docker push 790267619968.dkr.ecr.ap-northeast-2.amazonaws.com/dockerimage:${innerImageName}"
                                            }
                                        }
                                    }
                                    
                                    def eksworkCluster = "eks-work-Cluster"

// AWS 자격 증명 사용
withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws_connection', accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
    // AWS CLI를 사용하여 OIDC URL 가져오기
    def oidcUrl = sh(script: "aws eks describe-cluster --name ${eksworkCluster} --query 'cluster.identity.oidc.issuer' --output text", returnStdout: true).trim()
    echo "OIDC URL: ${oidcUrl}"

    // 공급자 존재 여부 확인
    def providerExists = sh(script: "aws iam list-open-id-connect-providers --query \"contains(OpenIDConnectProviderList[].Url, '${oidcUrl}')\" --output text", returnStdout: true).trim()
    echo "Provider Exists: ${providerExists}"

    // OIDC 공급자가 존재하지 않으면 생성 과정 진행
    if (providerExists.toLowerCase() == 'false') {
        // SSL 인증서에서 지문 생성
        def thumbprint = sh(script: """
            openssl s_client -servername ${oidcUrl.split('/')[2]} -connect ${oidcUrl.split('/')[2]}:443 </dev/null 2>/dev/null | openssl x509 -noout -fingerprint -sha1 | cut -d'=' -f2 | tr -d ':'
        """, returnStdout: true).trim()
        echo "OIDC Thumbprint: ${thumbprint}"

        // OIDC 공급자를 AWS에 등록
        sh """
            aws iam create-open-id-connect-provider \
            --url ${oidcUrl} \
            --client-id-list sts.amazonaws.com \
            --thumbprint-list ${thumbprint}
        """
    } else {
        echo "OIDC Provider already exists, skipping creation."
    }
}
                                    // YAML 파일을 원격 호스트로 전송하고 적용
                                    sh "scp -o StrictHostKeyChecking=no ${WORKSPACE}/ott_infra.yml ec2-user@${BASTION_HOST}:/home/ec2-user/"
                                    // AWS ID 가져오기
                                    AWS_ID = sh(script: "aws sts get-caller-identity --query 'Account' --output text", returnStdout: true).trim()
                                    echo "AWS Account ID: ${AWS_ID}"
                                    // VPC ID 가져오기
                                    VPC_ID = sh(script: "aws ec2 describe-vpcs --filters 'Name=tag:Name,Values=eks-work-VPC' --query 'Vpcs[0].VpcId' --output text", returnStdout: true).trim()
                                    echo "VPC ID: ${VPC_ID}"
                                    sh """
                                    ssh -o StrictHostKeyChecking=no ec2-user@${BASTION_HOST} 'bash -s' <<EOF
                                    sed -i 's/aws_id/${AWS_ID}/g' /home/ec2-user/ott_infra.yml
                                    sed -i 's/vpc_id/${VPC_ID}/g' /home/ec2-user/ott_infra.yml
EOF
                                    """
                                    sh """
                                        ssh -o StrictHostKeyChecking=no ec2-user@${BASTION_HOST} '
                                            kubectl apply -f /home/ec2-user/ott_infra.yml
                                        '
                                    """

                                    // ECR 이미지로 디플로이먼트 변경
                                    services.each { innerService ->
                                        // innerService 이름과 빌드 번호를 사용하여 이미지 이름 생성
                                        def innerImageName = "${innerService}-${env.BUILD_NUMBER}"
                                        // SSH를 통해 Kubernetes 디플로이먼트 업데이트 명령 실행
                                        sh """
                                            ssh -o StrictHostKeyChecking=no ec2-user@${BASTION_HOST} '
                                            kubectl set image deployment/${innerService}-deployment ${innerService}-container=790267619968.dkr.ecr.ap-northeast-2.amazonaws.com/dockerimage:${innerImageName}
                                            '
                                        """
                                    }
                                } else {
                                    echo "Deployment exists. Skipping Docker build and push."
                                }
                            }
                        } else {
                            echo "Skipping stage as env.RUN_DOCKER is 'false' and Jenkinsfile has changed."
                        }
                    }
                }
            

            post {
                success {
                    script {
                        def koreaTime = new Date().format("yyyy-MM-dd HH:mm:ss", TimeZone.getTimeZone('Asia/Seoul'))
                        def message = ":white_check_mark: 빌드번호 : ${buildNumber}\n컨테이너 배포 성공!\n작업 시간: ${koreaTime}"
                        if (!isJenkinsfileOrYamlChanged()) {
                            slackSend(channel: '#ott_noti', message: message)
                        }
                    }
                }
                failure {
                    script {
                        def koreaTime = new Date().format("yyyy-MM-dd HH:mm:ss", TimeZone.getTimeZone('Asia/Seoul'))
                        def message = ":x: 빌드번호 : ${buildNumber}\n컨테이너 배포 실패!\n작업 시간: ${koreaTime}"
                        if (!isJenkinsfileOrYamlChanged()) {
                            slackSend(channel: '#ott_noti', message: message)
                        }
                    }
                }
            }
        }

        stage('Backup to S3') {
            when {
                anyOf {
                    expression { env.RUN_TERRAFORM == 'true' }
                    expression { env.RUN_DOCKER == 'true' }
                }
            }
            steps {
                script {
                    def previousCommit = sh(script: "git rev-parse HEAD^", returnStdout: true).trim()
                    def currentCommit = sh(script: "git rev-parse HEAD", returnStdout: true).trim()

                    if (env.RUN_TERRAFORM == 'true') {
                        def changedTerraformFiles = sh(script: "git diff --name-only ${previousCommit} ${currentCommit} -- ${WORKSPACE}/Terraform/*.tf", returnStdout: true).trim().split("\n")
                        changedTerraformFiles.each { file ->
                            sh "aws s3 cp ${file} s3://${S3_BUCKET}/terraform-backup/${file.tokenize('/')[-1]}"
                        }
                    }

                    if (env.RUN_DOCKER == 'true') {
                        def changedDockerDirs = sh(script: "git diff --name-only ${previousCommit} ${currentCommit} -- ${WORKSPACE}/Image/", returnStdout: true).trim().split("\n").collect { it.split('/')[1] }.unique()
                        changedDockerDirs.each { dir ->
                            sh "aws s3 cp --recursive ${WORKSPACE}/Image/${dir} s3://${S3_BUCKET}/docker-backup/${dir}/"
                        }
                    }
                }
            }
            post {
                success {
                    script {
                        def koreaTime = new Date().format("yyyy-MM-dd HH:mm:ss", TimeZone.getTimeZone('Asia/Seoul'))
                        def message = ":white_check_mark: 빌드번호 : ${buildNumber}\nS3 백업 성공!\n작업 시간: ${koreaTime}"
                        slackSend(channel: '#ott_noti', message: message)
                    }
                }
                failure {
                    script {
                        def koreaTime = new Date().format("yyyy-MM-dd HH:mm:ss", TimeZone.getTimeZone('Asia/Seoul'))
                        def message = ":x: 빌드번호 : ${buildNumber}\nS3 백업 실패!\n작업 시간: ${koreaTime}"
                        slackSend(channel: '#ott_noti', message: message)
                    }
                }
            }
        }
    }


    post {
        success {
            script {
                def koreaTime = new Date().format("yyyy-MM-dd HH:mm:ss", TimeZone.getTimeZone('Asia/Seoul'))
                def message = ""

                if (env.RUN_TERRAFORM == 'false' && env.RUN_DOCKER == 'false') {
                    message = ":warning: 빌드번호 : ${buildNumber}\n설정파일 수정 성공!\n작업 시간: ${koreaTime}"
                    slackSend(channel: '#ott_noti', message: message)
                }
            }
        }
        failure {
            script {
                def koreaTime = new Date().format("yyyy-MM-dd HH:mm:ss", TimeZone.getTimeZone('Asia/Seoul'))
                def message = ""

                if (env.RUN_TERRAFORM == 'false' && env.RUN_DOCKER == 'false') {
                    message = ":warning: 빌드번호 : ${buildNumber}\n설정파일 수정 실패!\n작업 시간: ${koreaTime}"
                    slackSend(channel: '#ott_noti', message: message)
                }
            }
        }
    }
}
